# Stereo-Spot Helm Chart

Umbrella Helm chart for the stereo-spot pipeline: **web-ui**, **media-worker** (chunking + reassembly), and **video-worker**. Includes Ingress for the web UI and **KEDA** ScaledObjects: media-worker scales on chunking and reassembly queues (two triggers), video-worker on its queue.

## Structure

- **Chart.yaml** — Chart metadata.
- **values.yaml** — Defaults (image tag, resource requests, ingress settings). Queue URLs, bucket names, and table names are empty; they come from Terraform.
- **values-from-terraform.yaml** — **Generated by Terraform** on `terraform apply` (see [Terraform → values flow](#terraform--values-flow)). Contains S3 bucket names, DynamoDB table names, SQS queue URLs, and (after Step 4.4) ECR repository URIs.
- **templates/** — Deployments and Services for web-ui, media-worker, video-worker; Ingress for web-ui; KEDA TriggerAuthentication (IRSA) and two ScaledObjects (media-worker with two triggers, video-worker).
- **argo-application.yaml** — Argo CD Application manifest. Terraform (Step 4.4) installs the Argo CD controller and applies this manifest so Argo CD syncs this repo at `packages/helm`.

## Terraform → values flow

1. **packages/aws-infra** defines a `local_file` resource (`helm_values.tf`) that writes **packages/helm/values-from-terraform.yaml** when you run `terraform apply`.
2. The generated file sets:
   - `aws.inputBucketName`, `aws.outputBucketName`, `aws.jobsTableName`, `aws.segmentCompletionsTableName`, `aws.reassemblyTriggeredTableName`
   - `queues.chunking`, `queues.videoWorker`, `queues.reassembly`
   - `global.awsRegion`
3. After **Step 4.4** (EKS, ECR), Terraform will be extended to also output ECR repo URIs into this file (e.g. `images.webUi`, `images.mediaWorker`, etc.).
4. **Argo CD** is configured (in `argo-application.yaml`) to use both `values.yaml` and `values-from-terraform.yaml`, so the chart receives resource names without manual copy.

If you run Terraform from CI, ensure the generated `values-from-terraform.yaml` is either committed or passed into the Argo CD / Helm deploy step so the cluster has the correct queue URLs, bucket names, and table names.

## Image tags

Use a **single tag per release** (e.g. git SHA or pipeline run ID). Set in values:

```yaml
image:
  tag: abc1234
```

Override via `values-from-terraform.yaml` or Helm `--set image.tag=abc1234`. All three images (web-ui, media-worker, video-worker) should use the same tag for a given release.

## Deployment flow

1. **Terraform apply** — Provisions data plane (S3, SQS, DynamoDB) and, in Step 4.4, EKS, ECR, Argo CD controller. Writes **values-from-terraform.yaml**.
2. **Build and push images** — Build web-ui, media-worker, video-worker; push to ECR with the same tag.
3. **Update image tag** — Set `image.tag` (and in 4.4, `images.*` ECR URIs) in the values file used by Argo CD.
4. **Argo CD sync** — Argo CD syncs from this repo at `packages/helm` and applies the chart with the merged values. The cluster pulls the new images from ECR.

See [ARCHITECTURE.md](../../ARCHITECTURE.md) and [docs/IMPLEMENTATION_PLAN.md](../../docs/IMPLEMENTATION_PLAN.md) for the full pipeline and Step 4.4 (EKS, ECR, IRSA, Karpenter).

## Argo CD Application

**argo-application.yaml** points at this repo and path `packages/helm`. Update `spec.source.repoURL` to your Git remote (e.g. `https://github.com/YOUR_ORG/stereo-spot.git`). Terraform will apply this manifest after installing the Argo CD controller so Argo CD tracks the chart.

## Verification

Nx targets (run from repo root):

| Target | Description | Prerequisite |
|--------|-------------|--------------|
| `nx run helm:check` | Ensures `values-from-terraform.yaml` exists; fails with a clear message otherwise (run `nx run aws-infra:terraform-apply` once to generate it). Cacheable (based on inputs). | None. |
| `nx run helm:lint` | Lint the chart (`helm lint`). | None. |
| `nx run helm:template` | Render manifests with default + Terraform values. | Depends on `check` (runs it first if needed; check is cacheable). |
| `nx run helm:validate` | Same as template, then validate rendered YAML with `kubectl apply --dry-run=client`. | Depends on `check`. Requires `kubectl` in PATH. |

The **helm** project has `implicitDependencies: ["aws-infra"]`, so it is considered affected when aws-infra changes (e.g. `nx affected -t template`).

Manual commands (equivalent):

```bash
# Lint (no Terraform required)
helm lint packages/helm

# Template (after terraform apply, so values-from-terraform.yaml exists)
helm template stereo-spot packages/helm -f packages/helm/values.yaml -f packages/helm/values-from-terraform.yaml
```

Without `values-from-terraform.yaml`, the three workloads and Ingress still render; the two KEDA ScaledObjects are skipped when queue URLs are empty.
